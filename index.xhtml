<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>dom access for cobweb</title>

		<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
		<meta http-equiv="Pragma" content="no-cache"/>
		<meta http-equiv="Expires" content="0"/>
		<meta charset="utf-8"/>
		<!--link rel="stylesheet" type="text/css" href="https://rawgit.com/create3000/cobweb/master/stable/1/1.26/cobweb.css"/-->
		<link rel="stylesheet" type="text/css" href="./cobweb/cobweb.css"/>
		<script type="text/javascript" src="./cobweb/APcobweb.1.26.js"></script>
		
<style id="jsbin-css">
html, body {
	margin: 0px;
	padding: 0px;
	border: 0px;
	width: 100%;
	height: 100%;
	overflow: hidden;
}

body {
	background: black;
	color: white;
}

X3D {
	background: #414141;
	width: 600px;
	height: 400px;
}

.fallback {
	display: block;
	margin: 300px 0 0 0;
	text-align: center;
}
</style>
</head>
<body>
	<button onclick='random_color()'>new color</button>
	<button onclick='add_box()'>new box</button>
	<button onclick='remove_last_box()'>remove box</button>
	<button onclick='remove_last_material()'>remove material</button>
	
		<!--X3DCanvas url='"http://www.web3d.org/x3d-resources/content/examples/Basic/ChemicalMarkupLanguage/VitaminK.x3d"'-->
		<X3D id='dummy'>
	<Scene>
		<Transform translation='2 0 0'>
			<Shape>
			<!-- When attribute values are not specified, the default values from the X3D (or VRML) Specification are used. -->
				<Appearance>
					<Material></Material>
				</Appearance>
				<Box></Box>
			</Shape>
		</Transform>
		<Transform id='shell'>
		</Transform>
	</Scene>
			<p class="fallback">
				Your browser may not support all features required by Cobweb! You can use Firefox, <br/>
				because this is currently the choice of the choice. We will continuously keep you informed <br/>
				on technical developments and as soon as Cobweb is running in other browser too.
			</p>
		</X3D>

</body>
<script>
console.log('START')
$(function(){
console.log('after ready?')

	X3D(function(el){
		var mybrowser = X3D.getBrowser(el);
		//var myscene = mybrowser.createScene(); //probably not needed
		//myx3d = $('Scene')[0];
		var myx3d = document.querySelector('Scene');
		mybrowser.importDocument(myx3d); //now also attached x3dnode property to each node element
		// select the target node
		var target = myx3d;
		X3D.require(
			["cobweb/Parser/XMLParser"],
			function(XMLParser) {
				// create an observer instance
				var observer = new MutationObserver(function(mutations) {
					mutations.forEach(function(mutation) {
					//map attribute to x3dnode field
						console.log(mutation);
						var el = mutation.target;
						var parser = new XMLParser (mybrowser.currentScene, el);
						if (mutation.type == 'attributes') {
							//attributes
							var name = mutation.attributeName;
							var attribute = el.attributes.getNamedItem(name);
							var val  = el.attributes.getNamedItem(name).value ;
							parser.attribute(attribute, el.x3dnode);//almost there
							//only underscore gets update
							var field = el.x3dnode.getField(name);
							field.addEvent(); // set_field event
							//el.x3dnode[name] = val.split(" ");
							}
						if (mutation.type == 'childList') {
							//elements
							//parser.statement (el) should work for all new nodes
							//forEach addedNodes
							var addedEl = mutation.addedNodes[0];
							if (addedEl) {
								parser.statement(addedEl);
								//parser only adds uninitialized x3d nodes to scene
								//the setup function initializes only uninitialized nodes
								mybrowser.currentScene.setup();
							}
							//forEach removedNodes
							//removedNodes still has the removed nodes
							//probably best to find parent
							//parent = removedNode.parentElement.x3dnode
							//then use removedNode.x3dnode.removeParent(parent)
							//then perhaps set removedNode.x3dnode = null
							//then trigger redraw
							//scene.setup() does not work, set unitinialized somehow on parent ?
							//or find correct field in parent and emit set event like above
							//
							var removedEl = mutation.removedNodes[0];
							if (removedEl) {
								var parents = removedEl.x3dnode.getParents(); //parent should be field in parent node
								//deal with root nodes TODO
								for (var key in parents) { // only way to find property in parents object
									var parent = parents[key];
									//SFNode field or member of MFNode field or rootNode?
									var grandparents = parent.getParents();
									for (var k2 in grandparents){
										var gp = grandparents[k2];
										if (gp.getTypeName == 'MFNode') {
											var isMFNode = true;
											if (gp.getName = 'rootNodes') {
												var isRootNode = true;
											}
										}
									}
									parent.set(); // resets value of field to null
									if (isMFNode) {
										gp.addEvent();
										if (isRootNode) { // also remove from rootnodes
											var rootNodes = mybrowser.currentScene.getRootNodes();
											//find in array
											for (var key in parents) { // look through all parents
												parent = parents[key];
												var i = rootNodes.indexOf(parent);
												if (i !== -1) { break } // found it
											}																											
											rootNodes.splice(i,1); 
										}
									}
									else {parent.addEvent();}
									// trigger update event for this field
								}
							}
						}
				  	});
				});
				// configuration of the observer:
				var config = { attributes: true, childList: true, characterData: true, subtree: true };
				// pass in the target node, as well as the observer options
				observer.observe(target, config);
			}
		);
		
		
	});
});

var box_counter = 0;
var radius = 4;
var perBoxAngle = 2*Math.PI/12;

function random_color() {
	
	var m = document.querySelector("Material")
	//will be transferred to scene graph node 
	m.setAttribute("diffuseColor", Math.random()+" "+Math.random()+" "+Math.random());
	console.log(m);
}


function add_box() {

	var transform = document.createElement('Transform');
	transform.setAttribute('translation', radius * Math.cos(perBoxAngle * box_counter) + " " + radius * Math.sin(perBoxAngle * box_counter++) + " " + 0);
	var shape = document.createElement('Shape');
	var app = document.createElement('Appearance');
	var mat = document.createElement('Material');
	var box = document.createElement('Box');
	var shell = document.querySelector('Scene');
	app.appendChild(mat);
	shape.appendChild(app);
	shape.appendChild(box);
	transform.appendChild(shape);
	shell.appendChild(transform);
	radius = radius + box_counter/100;
}

function remove_last_box() {

	var trafos = document.querySelectorAll("Transform");
	var last_trafo = trafos[trafos.length - 1];
	last_trafo.remove();
	box_counter--;
	radius = radius - box_counter/100;

}

function remove_last_material() {

	var mats = document.querySelectorAll("Material");
	var last_mat = mats[mats.length - 1];
	last_mat.remove();
}
</script>

</html>
